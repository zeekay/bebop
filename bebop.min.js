var Bebop = (function () {
'use strict';

// src/client/event-emitter.coffee
var EventEmitter;
var slice = [].slice;

EventEmitter = (function() {
  function EventEmitter(opts) {
    if (opts == null) {
      opts = {};
    }
    this._listeners = {};
    this._allListeners = [];
  }

  EventEmitter.prototype.on = function(event, callback) {
    var base;
    if (event) {
      if ((base = this._listeners)[event] == null) {
        base[event] = [];
      }
      this._listeners[event].push(callback);
      return this._listeners[event].length - 1;
    } else {
      this._allListeners.push(callback);
      return this._allListeners.length - 1;
    }
  };

  EventEmitter.prototype.off = function(event, index) {
    if (!event) {
      return this._listeners = {};
    }
    if (index != null) {
      this._listeners[event][index] = null;
    } else {
      this._listeners[event] = {};
    }
  };

  EventEmitter.prototype.emit = function() {
    var args, event, i, j, len, len1, listener, listeners, ref, results;
    event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    listeners = this._listeners[event] || [];
    for (i = 0, len = listeners.length; i < len; i++) {
      listener = listeners[i];
      if (listener != null) {
        listener.apply(this, args);
      }
    }
    args.unshift(event);
    ref = this._allListeners;
    results = [];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      listener = ref[j];
      results.push(listener.apply(this, args));
    }
    return results;
  };

  return EventEmitter;

})();

var EventEmitter$1 = EventEmitter;

// ../handroll/node_modules/rollup-plugin-node-builtins/src/es6/qs.js
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};
function stringifyPrimitive(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
}

function stringify (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
}

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

function parse(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
}
var querystring = {
  encode: stringify,
  stringify: stringify,
  decode: parse,
  parse: parse
};

// src/client/utils.coffee
var random;

var isBrowser = (function() {
  return typeof window !== "undefined" && window !== null;
})();

var location$1 = (function() {
  if (isBrowser) {
    return window.location;
  } else {
    return {
      protocol: 'http:',
      hostname: 'localhost',
      port: '3333'
    };
  }
})();

var root = (function() {
  if (isBrowser) {
    return window;
  } else {
    return global;
  }
})();

random = function() {
  return (((1 + Math.random()) * 0x100000) | 0).toString(16);
};

var urlRandomize = function(url) {
  var path, query, ref;
  ref = url.split('?'), path = ref[0], query = ref[1];
  if (query == null) {
    return path + '?bop=' + random();
  }
  query = querystring.parse(query);
  query.bop = random();
  return path + '?' + querystring.stringify(query);
};

// src/client/tags.coffee
var tags;

var tags$1 = tags = {
  js: {
    link: 'src',
    name: 'script',
    type: 'text/javascript'
  },
  css: {
    link: 'href',
    name: 'link',
    type: 'text/css'
  }
};

// src/client/log.coffee
var Logger;
var levels;

levels = ['debug', 'info', 'warn', 'error'];

Logger = (function() {
  function Logger(options) {
    var fn, i, len, level;
    fn = (function(_this) {
      return function(level) {
        return _this[level] = function() {
          var args;
          args = Array.prototype.slice.call(arguments);
          args.unshift('bebop:' + level);
          return _this.log.apply(_this, args);
        };
      };
    })(this);
    for (i = 0, len = levels.length; i < len; i++) {
      level = levels[i];
      fn(level);
    }
  }

  Logger.prototype.log = function() {
    return typeof console !== "undefined" && console !== null ? console.log.apply(console, arguments) : void 0;
  };

  Logger.prototype.setLevels = function(levels) {
    return this.levels = levels;
  };

  Logger.prototype.debug = function(enable) {
    if (enable) {
      return this.setLevels(levels);
    } else {
      return this.setLevels(['info', 'warning', 'error']);
    }
  };

  return Logger;

})();

var log = new Logger();

// src/client/node.coffee
var parseFilename;

parseFilename = function(filename) {
  var ext, path, resource;
  path = filename.split('/');
  filename = path.pop();
  ext = filename.split('.')[1];
  resource = {
    ext: ext,
    filename: filename,
    path: path,
    tag: tags$1[ext]
  };
  return resource;
};

var findNode = function(filename) {
  var i, len, node, re, ref, resource;
  if (filename === '') {
    return;
  }
  if ((resource = parseFilename(filename)).tag == null) {
    return;
  }
  re = new RegExp(filename + '$');
  ref = document.getElementsByTagName(resource.tag.name);
  for (i = 0, len = ref.length; i < len; i++) {
    node = ref[i];
    if (re.test((node[resource.tag.link].split('?'))[0])) {
      resource.url = node[resource.tag.link];
      node._resource = resource;
      return node;
    }
  }
  return null;
};

var reloadNode = function(node) {
  var link;
  if (node._resource.ext === 'js') {
    node.parentNode.removeChild(node);
    return load(node._resource);
  }
  link = node._resource.tag.link;
  if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
    node[link] = '#break-the-url';
  }
  node[link] = urlRandomize(node._resource.url);
  return log.info('resource-reloaded', node[link]);
};

var load = function(resource) {
  var node;
  node = document.createElement(resource.tag.name);
  node[resource.tag.link] = resource.url;
  node.type = resource.tag.type;
  document.getElementsByTagName('head')[0].appendChild(node);
  return log.info('resource-loaded', node[resource.tag.link]);
};

// src/client/websocket.coffee
var WebSocket;
var fallback;
var ref;
var ref1;
var urls;

root.WEB_SOCKET_SWF_LOCATION = 'https://cdnjs.cloudflare.com/ajax/libs/web-socket-js/1.0.0/WebSocketMain.swf';

urls = ['https://cdnjs.cloudflare.com/ajax/libs/web-socket-js/1.0.0/web_socket.js', 'https://cdnjs.cloudflare.com/ajax/libs/web-socket-js/1.0.0/web_socket.min.js'];

fallback = function() {
  var i, len, url;
  for (i = 0, len = urls.length; i < len; i++) {
    url = urls[i];
    load(url);
  }
  return root.WebSocket;
};

WebSocket = (ref = (ref1 = root.WebSocket) != null ? ref1 : root.MozWebSocket) != null ? ref : fallback();

if (isBrowser) {
  WebSocket.identifier = location.href + ' - ' + navigator.userAgent;
} else {
  WebSocket.identifier = process.argv[1] + ' - node';
}

var WebSocket$1 = WebSocket;

// src/client/dir.coffee
var dir = function(object) {
  var i, properties, property, seen, valid;
  valid = function(name) {
    var i, invalid;
    invalid = ['arguments', 'caller', 'name', 'length', 'prototype'];
    for (i in invalid) {
      if (invalid[i] === name) {
        return false;
      }
    }
    return true;
  };
  properties = [];
  seen = {};
  if (Object.getOwnPropertyNames !== 'undefined') {
    properties = Object.getOwnPropertyNames(object);
    for (property in object) {
      properties.push(property);
    }
    properties = properties.filter(function(name) {
      return valid(name);
    });
    i = 0;
    while (i < properties.length) {
      seen[properties[i]] = '';
      i++;
    }
    return Object.keys(seen);
  } else {
    for (property in object) {
      properties.push(property);
    }
  }
  return properties;
};

// src/client/dump.coffee

// src/client/stacktrace.coffee
var chrome;
var firefox;
var other;
var stringifyArguments;

stringifyArguments = function(args) {
  var arg, i, result, slice;
  result = [];
  slice = Array.prototype.slice;
  i = 0;
  while (i < args.length) {
    arg = args[i];
    if (arg === void 0) {
      result[i] = 'undefined';
    } else if (arg === null) {
      result[i] = 'null';
    } else if (arg.constructor) {
      if (arg.constructor === Array) {
        if (arg.length < 3) {
          result[i] = '[' + stringifyArguments(arg) + ']';
        } else {
          result[i] = '[' + stringifyArguments(slice.call(arg, 0, 1)) + '...' + stringifyArguments(slice.call(arg, -1)) + ']';
        }
      } else if (arg.constructor === Object) {
        result[i] = '#object';
      } else if (arg.constructor === Function) {
        result[i] = '#function';
      } else if (arg.constructor === String) {
        result[i] = '"' + arg + '"';
      } else {
        if (arg.constructor === Number) {
          result[i] = arg;
        }
      }
    }
    ++i;
  }
  return result.join(',');
};

chrome = function(e) {
  var stack;
  stack = (e.stack + '\n').replace(/^\S[^\(]+?[\n$]/g, '').replace(/^\s+(at eval )?at\s+/g, '').replace(/^([^\(]+?)([\n$])/g, '{anonymous}()@$1$2').replace(/^Object.<anonymous>\s*\(([^\)]+)\)/g, '{anonymous}()@$1').split('\n');
  stack.pop();
  return stack;
};

firefox = function(e) {
  return e.stack.replace(/(?:\n@:0)?\s+$/m, '').replace(/^\(/g, '{anonymous}(').split('\n');
};

other = function(curr) {
  var ANON, args, fn, fnRE, maxStackSize, stack;
  ANON = '{anonymous}';
  fnRE = /function\s*([\w\-$]+)?\s*\(/i;
  stack = [];
  fn = void 0;
  args = void 0;
  maxStackSize = 10;
  while (curr && curr['arguments'] && stack.length < maxStackSize) {
    fn = (fnRE.test(curr.toString()) ? RegExp.$1 || ANON : ANON);
    args = Array.prototype.slice.call(curr['arguments'] || []);
    stack[stack.length] = fn + '(' + stringifyArguments(args) + ')';
    curr = curr.caller;
  }
  return stack;
};

var stacktrace = function(e) {
  if (e['arguments'] && e.stack) {
    return method.chrome(e);
  }
  if (e.stack) {
    return method.firefox(e);
  }
  return method.other(e);
};

// src/client/bebop.coffee
var Bebop$1;
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
var hasProp = {}.hasOwnProperty;

Bebop$1 = (function(superClass) {
  extend(Bebop, superClass);

  function Bebop(opts) {
    var hostname, port, protocol, ref, ref1, ref2, ref3, ref4, ref5;
    if (opts == null) {
      opts = {};
    }
    Bebop.__super__.constructor.call(this);
    protocol = (ref = opts.protocol) != null ? ref : location$1.protocol === 'http:' ? 'ws://' : 'wss://';
    hostname = (ref1 = opts.hostname) != null ? ref1 : location$1.hostname;
    port = (ref2 = opts.port) != null ? ref2 : location$1.port;
    this.address = (ref3 = opts.address) != null ? ref3 : protocol + hostname + ':' + port + '/_bebop';
    this.timeout = (ref4 = opts.timeout) != null ? ref4 : 1000;
    this.debug = (ref5 = opts.debug) != null ? ref5 : false;
    this.tries = 0;
    this.limit = -1;
    this._failed = false;
    this._retries = [];
    this._once = {
      error: false,
      closed: false
    };
    this.init(opts);
  }

  Bebop.prototype.defaultHandlers = {
    connected: function() {
      log.info('connected');
      this._once = {
        error: false,
        closed: false
      };
      return this.sendConnected();
    },
    reconnecting: function() {
      return log.info('reconnecting');
    },
    closed: function() {
      if (!this._once.closed) {
        log.info('closed');
      }
      return this._once.closed = true;
    },
    error: function() {
      if (!this._once.error) {
        log.error('error');
      }
      return this._once.error = true;
    },
    message: function(message) {
      log.debug('message');
      switch (message.type) {
        case 'complete':
          return this.sendComplete(message.name);
        case 'eval':
          return this.sendEval(message.code);
        case 'modified':
          return this.modified(message.filename);
        case 'reload':
          return this.reload();
        default:
          return log.warn("Unknown message type '" + message.type + "'", message);
      }
    }
  };

  Bebop.prototype.init = function(opts) {
    var handlers, k, ref, v;
    if (opts == null) {
      opts = {};
    }
    handlers = {
      connected: opts.onconnected,
      closed: opts.onclosed,
      error: opts.onerror,
      message: opts.onmessage,
      reconnecting: opts.reconnecting
    };
    ref = this.defaultHandlers;
    for (k in ref) {
      v = ref[k];
      if (handlers[k] == null) {
        handlers[k] = v;
      }
    }
    this.on('connect', (function(_this) {
      return function() {
        if ((_this.limit != null) && _this.limit >= 0) {
          if (_this.tries > _this.limit) {
            log.error('Bebop.connect', 'connection-failed: giving up!');
            return _this._failed = true;
          } else {
            return _this.tries = _this.tries + 1;
          }
        }
      };
    })(this));
    this.on('connected', (function(_this) {
      return function() {
        _this.tries = 0;
        return handlers.connected.apply(_this, arguments);
      };
    })(this));
    this.on('closed', (function(_this) {
      return function() {
        return handlers.closed.apply(_this, arguments);
      };
    })(this));
    this.on('error', (function(_this) {
      return function() {
        return handlers.error.apply(_this, arguments);
      };
    })(this));
    this.on('message', (function(_this) {
      return function() {
        return handlers.message.apply(_this, arguments);
      };
    })(this));
    return this.on('reconnecting', (function(_this) {
      return function() {
        return handlers.reconnecting.apply(_this, arguments);
      };
    })(this));
  };

  Bebop.prototype.connect = function() {
    var err;
    if (this._failed) {
      return;
    }
    this.emit('connecting');
    try {
      this.ws = new WebSocket$1(this.address);
    } catch (error1) {
      err = error1;
      log.warn('Failed to create WebSocket', err);
      return this.reconnect();
    }
    this.ws.onopen = (function(_this) {
      return function() {
        var args;
        _this.stopRetrying();
        args = Array.prototype.slice.call(arguments);
        args.unshift('connected');
        return _this.emit.apply(_this, args);
      };
    })(this);
    this.ws.onclose = (function(_this) {
      return function() {
        var args;
        args = Array.prototype.slice.call(arguments);
        args.unshift('closed');
        return _this.emit.apply(_this, args);
      };
    })(this);
    this.ws.onerror = (function(_this) {
      return function() {
        var args;
        args = Array.prototype.slice.call(arguments);
        args.unshift('error');
        return _this.emit.apply(_this, args);
      };
    })(this);
    this.ws.onmessage = (function(_this) {
      return function(e) {
        return _this.emit('message', JSON.parse(e.data));
      };
    })(this);
    if (isBrowser) {
      return root.addEventListener('beforeunload', (function(_this) {
        return function() {
          return _this.ws.close();
        };
      })(this));
    }
  };

  Bebop.prototype.reconnect = function() {
    if (this._failed) {
      return;
    }
    this.emit('reconnecting');
    return this._retries.push(root.setTimeout((function(_this) {
      return function() {
        return _this.connect();
      };
    })(this), this.timeout));
  };

  Bebop.prototype.stopRetrying = function() {
    var i, len, ref, t;
    this.tries = 0;
    ref = this._retries;
    for (i = 0, len = ref.length; i < len; i++) {
      t = ref[i];
      clearTimeout(t);
    }
    return this._retries = [];
  };

  Bebop.prototype.close = function() {
    return this.ws.close();
  };

  Bebop.prototype.send = function(msg) {
    this.emit('send', msg);
    return this.ws.send(JSON.stringify(msg));
  };

  Bebop.prototype.complete = function(code) {
    var e;
    this.emit('complete', code);
    try {
      return dir(eval_.call(root, code));
    } catch (error1) {
      e = error1;
      return [];
    }
  };

  Bebop.prototype["eval"] = function(code) {
    var e, error, res;
    this.emit('eval', code);
    try {
      return res = eval_.call(root, msg);
    } catch (error1) {
      e = error1;
      return error = {
        error: e.message,
        stack: stacktrace(e)
      };
    }
  };

  Bebop.prototype.modified = function(filename) {
    var node;
    this.emit('modified', filename);
    if (isBrowser) {
      node = findNode(filename);
      if (node && node._resource.tag.name !== 'script') {
        return reloadNode(node);
      } else {
        return this.reload(true);
      }
    }
  };

  Bebop.prototype.reload = function() {
    var ref;
    this.emit('reload');
    this.close();
    return (ref = root.location) != null ? ref.reload() : void 0;
  };

  Bebop.prototype.sendConnected = function() {
    return this.send({
      type: 'connected',
      identifier: this.ws.identifier
    });
  };

  Bebop.prototype.sendComplete = function(code) {
    return this.send({
      type: 'complete',
      result: this.complete(code)
    });
  };

  Bebop.prototype.sendEval = function(code) {
    return this.send({
      type: 'eval',
      result: this["eval"](code)
    });
  };

  return Bebop;

})(EventEmitter$1);

var Bebop$2 = Bebop$1;

// src/client/index.coffee
if (typeof window !== "undefined" && window !== null) {
  window.Bebop = Bebop$2;
}

return Bebop$2;

}());
