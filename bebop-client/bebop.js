// Generated by CoffeeScript 1.6.3
(function() {
  var Bebop, bebop, isBrowser, root;
  isBrowser = typeof window === 'undefined' ? false : true;
  root = isBrowser ? window : global;
  Bebop = (function() {
    function Bebop() {
      var hostname, port, protocol;
      protocol = window.location.protocol === 'http:' ? 'ws://' : 'wss://';
      hostname = window.location.hostname;
      port = window.location.port;
      this.address = protocol + hostname + ':' + port + '/_bebop';
      this.tries = 0;
    }

    Bebop.prototype.oncomplete = function(msg) {
      var e, obj;
      try {
        obj = eval_.call(root, msg);
        return this.send({
          type: 'complete',
          result: this.dir(obj)
        });
      } catch (_error) {
        e = _error;
        return this.send({
          type: 'complete',
          result: []
        });
      }
    };

    Bebop.prototype.oneval = function(msg) {
      var e, error, res;
      try {
        res = eval_.call(root, msg);
        return this.send({
          type: 'eval',
          result: res
        });
      } catch (_error) {
        e = _error;
        error = {
          error: e.message,
          stack: this.stacktrace(e)
        };
        return this.send({
          type: 'eval',
          result: error
        });
      }
    };

    Bebop.prototype.onmodified = function(filename) {
      var node;
      if (isBrowser) {
        node = this.findNode(filename);
        if (node) {
          return this.reload(node);
        } else {
          return location.reload(true);
        }
      }
    };

    Bebop.prototype.onopen = function() {
      this.tries = 0;
      return this.log('Connected to Bebop');
    };

    Bebop.prototype.onclose = function() {
      return this.log('Connection to Bebop closed');
    };

    Bebop.prototype.close = function() {
      this.ws.onclose = function() {};
      return this.ws.close();
    };

    Bebop.prototype.reload = function(node) {
      var link;
      if (node._resource.ext === 'js') {
        node.parentNode.removeChild(node);
        return this.load(node._resource);
      }
      link = node._resource.tag.link;
      node[link] = this.urlRandomize(node._resource.url);
      return this.log('Reloaded ' + node[link]);
    };

    Bebop.prototype.load = function(resource) {
      var node;
      node = document.createElement(resource.tag.name);
      node[resource.tag.link] = resource.url;
      node.type = resource.tag.type;
      document.getElementsByTagName('head')[0].appendChild(node);
      return this.log('Loaded ' + node[resource.tag.link]);
    };

    Bebop.prototype.dir = function(object) {
      var i, properties, property, seen, valid;
      valid = function(name) {
        var i, invalid;
        invalid = ['arguments', 'caller', 'name', 'length', 'prototype'];
        for (i in invalid) {
          if (invalid[i] === name) {
            return false;
          }
        }
        return true;
      };
      properties = [];
      seen = {};
      if (Object.getOwnPropertyNames !== 'undefined') {
        properties = Object.getOwnPropertyNames(object);
        for (property in object) {
          properties.push(property);
        }
        properties = properties.filter(function(name) {
          return valid(name);
        });
        i = 0;
        while (i < properties.length) {
          seen[properties[i]] = '';
          i++;
        }
        return Object.keys(seen);
      } else {
        for (property in object) {
          properties.push(property);
        }
      }
      return properties;
    };

    Bebop.prototype.dump = function(object) {
      var derez, objects, paths,
        _this = this;
      objects = [];
      paths = [];
      return (derez = function(value, path) {
        var e, funcname, i, name, nu, properties;
        switch (typeof value) {
          case 'object':
            if (!value) {
              return null;
            }
            i = 0;
            while (i < objects.length) {
              if (objects[i] === value) {
                return {
                  $ref: paths[i]
                };
              }
              i += 1;
            }
            objects.push(value);
            paths.push(path);
            if (Object.prototype.toString.apply(value) === '[object Array]') {
              nu = [];
              i = 0;
              while (i < value.length) {
                nu[i] = derez(value[i], path + '[' + i + ']');
                i += 1;
              }
            } else {
              nu = {};
              properties = _this.dir(value);
              for (i in properties) {
                name = properties[i];
                if (typeof value[name] === 'function') {
                  funcname = (value[name].toString().split(')')[0] + ')').replace(' ' + name, '');
                  if (_this.dir(value[name]).length < 1) {
                    nu[name] = funcname;
                  } else {
                    try {
                      nu[name] = derez(value[name], path + '[' + JSON.stringify(name) + ']');
                    } catch (_error) {}
                  }
                } else {
                  try {
                    nu[name] = derez(value[name], path + '[' + JSON.stringify(name) + ']');
                  } catch (_error) {}
                }
              }
            }
            return nu;
          case 'number':
          case 'string':
          case 'boolean':
            return value;
          case 'function':
            try {
              properties = _this.dir(value);
              objects.push(value);
              paths.push(path);
              nu = {};
              for (i in properties) {
                name = properties[i];
                if (typeof value[name] === 'function') {
                  funcname = (value[name].toString().split(')')[0] + ')').replace(' ' + name, '');
                  if (_this.dir(value[name]).length < 1) {
                    nu[name] = funcname;
                  } else {
                    nu[name] = derez(value[name], path + '[' + JSON.stringify(name) + ']');
                  }
                } else {
                  nu[name] = derez(value[name], path + '[' + JSON.stringify(name) + ']');
                }
              }
              return nu;
            } catch (_error) {
              e = _error;
              return nu;
            }
        }
      })(object, '$');
    };

    Bebop.prototype.log = function() {
      if (root.console) {
        return console.log.apply(console, arguments);
      }
    };

    Bebop.prototype.connect = function() {
      var WebSocket, err,
        _this = this;
      if (!(this.tries < 10)) {
        this.log('Failed to connect to Bebop, giving up!');
        return;
      }
      this.tries++;
      WebSocket = root.WebSocket || root.MozWebSocket;
      if (WebSocket == null) {
        if (isBrowser) {
          this.webSocketFallback();
        } else {
          WebSocket = require('ws');
        }
      }
      try {
        this.ws = new WebSocket(this.address);
      } catch (_error) {
        err = _error;
        root.setTimeout(function() {
          return _this.connect;
        }, 500);
        return;
      }
      if (isBrowser) {
        root.onbeforeunload = function() {
          return _this.ws.close();
        };
      }
      this.ws.onopen = function() {
        var identifier;
        _this.onopen();
        if (isBrowser) {
          identifier = location.href + ' - ' + navigator.userAgent;
        } else {
          identifier = process.argv[1] + ' - node';
        }
        return _this.send({
          type: 'connected',
          identifier: identifier
        });
      };
      this.ws.onclose = function() {
        return;
        return setTimeout(function() {
          return _this.connect();
        }, 500);
      };
      this.ws.onerror = function() {
        return setTimeout(function() {
          return _this.connect();
        }, 500);
      };
      return this.ws.onmessage = function(message) {
        message = JSON.parse(message.data);
        _this.log(message);
        switch (message.type) {
          case 'complete':
            return _this.oncomplete(message.name);
          case 'eval':
            return _this.oneval(message.code);
          case 'modified':
            return _this.onmodified(message.filename);
          case 'reload':
            return setTimeout(function() {
              _this.close();
              return location.reload(true);
            }, 2000);
        }
      };
    };

    Bebop.prototype.send = function(msg) {
      return this.ws.send(JSON.stringify(msg));
    };

    Bebop.prototype.webSocketFallback = function() {
      var urls;
      root.WEB_SOCKET_SWF_LOCATION = 'https://github.com/gimite/web-socket-js/blob/master/WebSocketMain.swf?raw=true';
      urls = ['https://github.com/gimite/web-socket-js/blob/master/swfobject.js?raw=true', 'https://github.com/gimite/web-socket-js/blob/master/web_socket.js?raw=true'];
      this.load(this.urlParse(urls[0]));
      return this.load(this.urlParse(urls[1]));
    };

    Bebop.prototype.tags = {
      js: {
        link: 'src',
        name: 'script',
        type: 'text/javascript'
      },
      css: {
        link: 'href',
        name: 'link',
        type: 'text/css'
      }
    };

    Bebop.prototype.parseFilename = function(filename) {
      var ext, path, resource;
      path = filename.split('/');
      filename = path.pop();
      ext = filename.split('.')[1];
      resource = {
        ext: ext,
        filename: filename,
        path: path,
        tag: this.tags[ext]
      };
      return resource;
    };

    Bebop.prototype.findNode = function(filename) {
      var node, resource, _i, _len, _ref;
      if (filename === '') {
        return;
      }
      if ((resource = this.parseFilename(filename)).tag == null) {
        return;
      }
      _ref = document.getElementsByTagName(resource.tag.name);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        if (node[resource.tag.link].indexOf(resource.filename !== -1)) {
          resource.url = node[resource.tag.link];
          node._resource = resource;
          return node;
        }
      }
      return null;
    };

    Bebop.prototype.urlRandomize = function(url) {
      url = url.replace(/[?&]bebop=\w+/, '');
      url += (url.indexOf('?') === -1 ? '?' : '&');
      return url + 'bebop=' + (((1 + Math.random()) * 0x100000) | 0).toString(16);
    };

    Bebop.prototype.exportGlobals = function() {
      var globals, key, original, _results,
        _this = this;
      globals = {
        bebop: this,
        dir: function(obj) {
          return _this.dir(obj);
        },
        dump: function(obj) {
          return _this.dump(obj);
        }
      };
      _results = [];
      for (key in globals) {
        if (typeof root[key] !== 'undefined') {
          original = root[key];
          root[key] = globals[key];
          _results.push(root[key]._original = original);
        } else {
          _results.push(root[key] = globals[key]);
        }
      }
      return _results;
    };

    Bebop.prototype.stacktrace = function(e) {
      var method;
      method = {
        chrome: function(e) {
          var stack;
          stack = (e.stack + '\n').replace(/^\S[^\(]+?[\n$]/g, '').replace(/^\s+(at eval )?at\s+/g, '').replace(/^([^\(]+?)([\n$])/g, '{anonymous}()@$1$2').replace(/^Object.<anonymous>\s*\(([^\)]+)\)/g, '{anonymous}()@$1').split('\n');
          stack.pop();
          return stack;
        },
        firefox: function(e) {
          return e.stack.replace(/(?:\n@:0)?\s+$/m, '').replace(/^\(/g, '{anonymous}(').split('\n');
        },
        other: function(curr) {
          var ANON, args, fn, fnRE, maxStackSize, stack;
          ANON = '{anonymous}';
          fnRE = /function\s*([\w\-$]+)?\s*\(/i;
          stack = [];
          fn = void 0;
          args = void 0;
          maxStackSize = 10;
          while (curr && curr['arguments'] && stack.length < maxStackSize) {
            fn = (fnRE.test(curr.toString()) ? RegExp.$1 || ANON : ANON);
            args = Array.prototype.slice.call(curr['arguments'] || []);
            stack[stack.length] = fn + '(' + this.stringifyArguments(args) + ')';
            curr = curr.caller;
          }
          return stack;
        },
        stringifyArguments: function(args) {
          var arg, i, result, slice;
          result = [];
          slice = Array.prototype.slice;
          i = 0;
          while (i < args.length) {
            arg = args[i];
            if (arg === void 0) {
              result[i] = 'undefined';
            } else if (arg === null) {
              result[i] = 'null';
            } else if (arg.constructor) {
              if (arg.constructor === Array) {
                if (arg.length < 3) {
                  result[i] = '[' + this.stringifyArguments(arg) + ']';
                } else {
                  result[i] = '[' + this.stringifyArguments(slice.call(arg, 0, 1)) + '...' + this.stringifyArguments(slice.call(arg, -1)) + ']';
                }
              } else if (arg.constructor === Object) {
                result[i] = '#object';
              } else if (arg.constructor === Function) {
                result[i] = '#function';
              } else if (arg.constructor === String) {
                result[i] = '"' + arg + '"';
              } else {
                if (arg.constructor === Number) {
                  result[i] = arg;
                }
              }
            }
            ++i;
          }
          return result.join(',');
        }
      };
      if (e['arguments'] && e.stack) {
        return method.chrome(e);
      } else {
        if (e.stack) {
          return method.firefox(e);
        }
      }
      return method.other(e);
    };

    return Bebop;

  })();
  bebop = new Bebop();
  if (isBrowser) {
    bebop.connect();
    return bebop.exportGlobals();
  } else {
    exports.Bebop = Bebop;
    return exports.start = function(useRepl) {
      var repl, util;
      if (useRepl) {
        util = require('util');
        repl = require('repl');
        repl.writer = function(obj, showHidden, depth) {
          return util.inspect(obj, showHidden, depth, true);
        };
        bebop.onopen = function() {
          return repl.start('bebop> ', null, null, true);
        };
        bebop.exportGlobals();
      }
      return bebop.connect();
    };
  }
})();

/*
//@ sourceMappingURL=bebop.map
*/
