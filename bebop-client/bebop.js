// Generated by CoffeeScript 1.8.0
(function() {
  var Bebop, isBrowser, root;

  isBrowser = typeof window === 'undefined' ? false : true;

  root = isBrowser ? window : global;

  if (!isBrowser) {
    root.location = {
      protocol: 'http:',
      hostname: 'localhost',
      port: '3333'
    };
  }

  Bebop = (function() {
    function Bebop(opts) {
      var hostname, port, protocol, _ref, _ref1, _ref2, _ref3;
      protocol = (_ref = opts.protocol) != null ? _ref : location.protocol === 'http:' ? 'ws://' : 'wss://';
      hostname = (_ref1 = opts.hostname) != null ? _ref1 : location.hostname;
      port = (_ref2 = opts.port) != null ? _ref2 : location.port;
      this.address = (_ref3 = opts.address) != null ? _ref3 : protocol + hostname + ':' + port + '/_bebop';
      this.tries = 0;
    }

    Bebop.prototype.oncomplete = function(msg) {
      var e, obj;
      try {
        obj = eval_.call(root, msg);
        return this.send({
          type: 'complete',
          result: this.dir(obj)
        });
      } catch (_error) {
        e = _error;
        return this.send({
          type: 'complete',
          result: []
        });
      }
    };

    Bebop.prototype.oneval = function(msg) {
      var e, error, res;
      try {
        res = eval_.call(root, msg);
        return this.send({
          type: 'eval',
          result: res
        });
      } catch (_error) {
        e = _error;
        error = {
          error: e.message,
          stack: this.stacktrace(e)
        };
        return this.send({
          type: 'eval',
          result: error
        });
      }
    };

    Bebop.prototype.onmodified = function(filename) {
      var node;
      if (isBrowser) {
        node = this.findNode(filename);
        if (node && node._resource.tag.name !== 'script') {
          return this.reload(node);
        } else {
          return location.reload(true);
        }
      }
    };

    Bebop.prototype.onopen = function() {
      this.tries = 0;
      return this.log('connected');
    };

    Bebop.prototype.onclose = function() {
      return this.log('closed');
    };

    Bebop.prototype.close = function() {
      this.ws.onclose = function() {};
      return this.ws.close();
    };

    Bebop.prototype.reload = function(node) {
      var link;
      if (node._resource.ext === 'js') {
        node.parentNode.removeChild(node);
        return this.load(node._resource);
      }
      link = node._resource.tag.link;
      if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
        node[link] = '#break-the-url';
      }
      node[link] = this.urlRandomize(node._resource.url);
      return this.log('resource-reloaded', node[link]);
    };

    Bebop.prototype.load = function(resource) {
      var node;
      node = document.createElement(resource.tag.name);
      node[resource.tag.link] = resource.url;
      node.type = resource.tag.type;
      document.getElementsByTagName('head')[0].appendChild(node);
      return this.log('resource-loaded', node[resource.tag.link]);
    };

    Bebop.prototype.dir = function(object) {
      var i, properties, property, seen, valid;
      valid = function(name) {
        var i, invalid;
        invalid = ['arguments', 'caller', 'name', 'length', 'prototype'];
        for (i in invalid) {
          if (invalid[i] === name) {
            return false;
          }
        }
        return true;
      };
      properties = [];
      seen = {};
      if (Object.getOwnPropertyNames !== 'undefined') {
        properties = Object.getOwnPropertyNames(object);
        for (property in object) {
          properties.push(property);
        }
        properties = properties.filter(function(name) {
          return valid(name);
        });
        i = 0;
        while (i < properties.length) {
          seen[properties[i]] = '';
          i++;
        }
        return Object.keys(seen);
      } else {
        for (property in object) {
          properties.push(property);
        }
      }
      return properties;
    };

    Bebop.prototype.dump = function(object) {
      var derez, objects, paths;
      objects = [];
      paths = [];
      return (derez = (function(_this) {
        return function(value, path) {
          var e, funcname, i, name, nu, properties;
          switch (typeof value) {
            case 'object':
              if (!value) {
                return null;
              }
              i = 0;
              while (i < objects.length) {
                if (objects[i] === value) {
                  return {
                    $ref: paths[i]
                  };
                }
                i += 1;
              }
              objects.push(value);
              paths.push(path);
              if (Object.prototype.toString.apply(value) === '[object Array]') {
                nu = [];
                i = 0;
                while (i < value.length) {
                  nu[i] = derez(value[i], path + '[' + i + ']');
                  i += 1;
                }
              } else {
                nu = {};
                properties = _this.dir(value);
                for (i in properties) {
                  name = properties[i];
                  if (typeof value[name] === 'function') {
                    funcname = (value[name].toString().split(')')[0] + ')').replace(' ' + name, '');
                    if (_this.dir(value[name]).length < 1) {
                      nu[name] = funcname;
                    } else {
                      try {
                        nu[name] = derez(value[name], path + '[' + JSON.stringify(name) + ']');
                      } catch (_error) {}
                    }
                  } else {
                    try {
                      nu[name] = derez(value[name], path + '[' + JSON.stringify(name) + ']');
                    } catch (_error) {}
                  }
                }
              }
              return nu;
            case 'number':
            case 'string':
            case 'boolean':
              return value;
            case 'function':
              try {
                properties = _this.dir(value);
                objects.push(value);
                paths.push(path);
                nu = {};
                for (i in properties) {
                  name = properties[i];
                  if (typeof value[name] === 'function') {
                    funcname = (value[name].toString().split(')')[0] + ')').replace(' ' + name, '');
                    if (_this.dir(value[name]).length < 1) {
                      nu[name] = funcname;
                    } else {
                      nu[name] = derez(value[name], path + '[' + JSON.stringify(name) + ']');
                    }
                  } else {
                    nu[name] = derez(value[name], path + '[' + JSON.stringify(name) + ']');
                  }
                }
                return nu;
              } catch (_error) {
                e = _error;
                return nu;
              }
          }
        };
      })(this))(object, '$');
    };

    Bebop.prototype.log = function(event, message) {
      if (root.console == null) {
        return;
      }
      if (message) {
        return console.log("bebop:" + event, message);
      } else {
        return console.log("bebop:" + event);
      }
    };

    Bebop.prototype.connect = function() {
      var WebSocket, err;
      if (!(this.tries < 10)) {
        this.log('connection-failed', 'giving up!');
        return;
      }
      this.tries++;
      WebSocket = root.WebSocket || root.MozWebSocket;
      if (WebSocket == null) {
        if (isBrowser) {
          this.webSocketFallback();
        } else {
          WebSocket = require('ws');
        }
      }
      try {
        this.ws = new WebSocket(this.address);
      } catch (_error) {
        err = _error;
        root.setTimeout((function(_this) {
          return function() {
            return _this.connect;
          };
        })(this), 500);
        return;
      }
      if (isBrowser) {
        root.onbeforeunload = (function(_this) {
          return function() {
            return _this.ws.close();
          };
        })(this);
      }
      this.ws.onopen = (function(_this) {
        return function() {
          var identifier;
          _this.onopen();
          if (isBrowser) {
            identifier = location.href + ' - ' + navigator.userAgent;
          } else {
            identifier = process.argv[1] + ' - node';
          }
          return _this.send({
            type: 'connected',
            identifier: identifier
          });
        };
      })(this);
      this.ws.onclose = (function(_this) {
        return function() {
          return;
          return setTimeout(function() {
            return _this.connect();
          }, 500);
        };
      })(this);
      this.ws.onerror = (function(_this) {
        return function() {
          return setTimeout(function() {
            return _this.connect();
          }, 500);
        };
      })(this);
      return this.ws.onmessage = (function(_this) {
        return function(message) {
          message = JSON.parse(message.data);
          switch (message.type) {
            case 'complete':
              return _this.oncomplete(message.name);
            case 'eval':
              return _this.oneval(message.code);
            case 'modified':
              return _this.onmodified(message.filename);
            case 'reload':
              return setTimeout(function() {
                _this.close();
                return location.reload(true);
              }, 2000);
          }
        };
      })(this);
    };

    Bebop.prototype.send = function(msg) {
      return this.ws.send(JSON.stringify(msg));
    };

    Bebop.prototype.webSocketFallback = function() {
      var urls;
      root.WEB_SOCKET_SWF_LOCATION = 'https://github.com/gimite/web-socket-js/blob/master/WebSocketMain.swf?raw=true';
      urls = ['https://github.com/gimite/web-socket-js/blob/master/swfobject.js?raw=true', 'https://github.com/gimite/web-socket-js/blob/master/web_socket.js?raw=true'];
      this.load(this.urlParse(urls[0]));
      return this.load(this.urlParse(urls[1]));
    };

    Bebop.prototype.tags = {
      js: {
        link: 'src',
        name: 'script',
        type: 'text/javascript'
      },
      css: {
        link: 'href',
        name: 'link',
        type: 'text/css'
      }
    };

    Bebop.prototype.parseFilename = function(filename) {
      var ext, path, resource;
      path = filename.split('/');
      filename = path.pop();
      ext = filename.split('.')[1];
      resource = {
        ext: ext,
        filename: filename,
        path: path,
        tag: this.tags[ext]
      };
      return resource;
    };

    Bebop.prototype.findNode = function(filename) {
      var node, re, resource, _i, _len, _ref;
      if (filename === '') {
        return;
      }
      if ((resource = this.parseFilename(filename)).tag == null) {
        return;
      }
      re = new RegExp(filename + '$');
      _ref = document.getElementsByTagName(resource.tag.name);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        if (re.test((node[resource.tag.link].split('?'))[0])) {
          resource.url = node[resource.tag.link];
          node._resource = resource;
          return node;
        }
      }
      return null;
    };

    Bebop.prototype.urlRandomize = function(url) {
      url = url.replace(/[?&]bebop=\w+/, '');
      url += (url.indexOf('?') === -1 ? '?' : '&');
      return url + 'bebop=' + (((1 + Math.random()) * 0x100000) | 0).toString(16);
    };

    Bebop.prototype.exportGlobals = function() {
      var globals, key, original, _results;
      globals = {
        bebop: this,
        dir: (function(_this) {
          return function(obj) {
            return _this.dir(obj);
          };
        })(this),
        dump: (function(_this) {
          return function(obj) {
            return _this.dump(obj);
          };
        })(this)
      };
      _results = [];
      for (key in globals) {
        if (typeof root[key] !== 'undefined') {
          original = root[key];
          root[key] = globals[key];
          _results.push(root[key]._original = original);
        } else {
          _results.push(root[key] = globals[key]);
        }
      }
      return _results;
    };

    Bebop.prototype.stacktrace = function(e) {
      var method;
      method = {
        chrome: function(e) {
          var stack;
          stack = (e.stack + '\n').replace(/^\S[^\(]+?[\n$]/g, '').replace(/^\s+(at eval )?at\s+/g, '').replace(/^([^\(]+?)([\n$])/g, '{anonymous}()@$1$2').replace(/^Object.<anonymous>\s*\(([^\)]+)\)/g, '{anonymous}()@$1').split('\n');
          stack.pop();
          return stack;
        },
        firefox: function(e) {
          return e.stack.replace(/(?:\n@:0)?\s+$/m, '').replace(/^\(/g, '{anonymous}(').split('\n');
        },
        other: function(curr) {
          var ANON, args, fn, fnRE, maxStackSize, stack;
          ANON = '{anonymous}';
          fnRE = /function\s*([\w\-$]+)?\s*\(/i;
          stack = [];
          fn = void 0;
          args = void 0;
          maxStackSize = 10;
          while (curr && curr['arguments'] && stack.length < maxStackSize) {
            fn = (fnRE.test(curr.toString()) ? RegExp.$1 || ANON : ANON);
            args = Array.prototype.slice.call(curr['arguments'] || []);
            stack[stack.length] = fn + '(' + this.stringifyArguments(args) + ')';
            curr = curr.caller;
          }
          return stack;
        },
        stringifyArguments: function(args) {
          var arg, i, result, slice;
          result = [];
          slice = Array.prototype.slice;
          i = 0;
          while (i < args.length) {
            arg = args[i];
            if (arg === void 0) {
              result[i] = 'undefined';
            } else if (arg === null) {
              result[i] = 'null';
            } else if (arg.constructor) {
              if (arg.constructor === Array) {
                if (arg.length < 3) {
                  result[i] = '[' + this.stringifyArguments(arg) + ']';
                } else {
                  result[i] = '[' + this.stringifyArguments(slice.call(arg, 0, 1)) + '...' + this.stringifyArguments(slice.call(arg, -1)) + ']';
                }
              } else if (arg.constructor === Object) {
                result[i] = '#object';
              } else if (arg.constructor === Function) {
                result[i] = '#function';
              } else if (arg.constructor === String) {
                result[i] = '"' + arg + '"';
              } else {
                if (arg.constructor === Number) {
                  result[i] = arg;
                }
              }
            }
            ++i;
          }
          return result.join(',');
        }
      };
      if (e['arguments'] && e.stack) {
        return method.chrome(e);
      } else {
        if (e.stack) {
          return method.firefox(e);
        }
      }
      return method.other(e);
    };

    return Bebop;

  })();

  if (isBrowser) {
    root.Bebop = Bebop;
  } else {
    module.exports = Bebop;
    exports.start = function(opts) {
      var bebop, repl, util;
      if (opts == null) {
        opts = {};
      }
      bebop = new Bebop(opts);
      if (opts.useRepl) {
        repl = require('repl');
        util = require('util');
        repl.writer = function(obj, showHidden, depth) {
          return util.inspect(obj, showHidden, depth, true);
        };
        bebop.onopen = function() {
          return repl.start('bebop> ', null, null, true);
        };
      }
      return bebop.connect();
    };
  }

}).call(this);

//# sourceMappingURL=bebop.js.map
