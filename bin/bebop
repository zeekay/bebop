#!/usr/bin/env node
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var exec = _interopDefault(require('executive'));
var fs = _interopDefault(require('fs'));
var os = _interopDefault(require('os'));
var vigil = _interopDefault(require('vigil'));
var basicAuth = _interopDefault(require('basic-auth-connect'));
var connect = _interopDefault(require('connect'));
var favicons = _interopDefault(require('connect-favicons'));
var http = _interopDefault(require('http'));
var logger = _interopDefault(require('morgan'));
var path = _interopDefault(require('path'));
var serveIndex = _interopDefault(require('serve-index'));
var serveStatic = _interopDefault(require('serve-static'));
var url = require('url');
var url__default = _interopDefault(url);
var colors = _interopDefault(require('colors/safe'));
var marked = _interopDefault(require('marked'));
var ws = _interopDefault(require('ws'));

// src/log.coffee
var _;
var fn;
var log;
var method;
var prettyError;
var prettyJSON;
var theme;

theme = {
  debug: 'blue',
  info: 'white',
  warn: 'yellow',
  error: 'red',
  bebop: 'black',
  modified: 'cyan',
  compiled: 'blue'
};

colors.setTheme(theme);

prettyJSON = function(obj) {
  return JSON.stringify(obj, null, 2);
};

prettyError = function(err) {
  var msg, std;
  std = [];
  if (err.stdout != null) {
    std.push(err.stdout);
  }
  if (err.stderr != null) {
    std.push(err.stderr);
  }
  if (std.length > 0) {
    return std.join('\n');
  } else {
    msg = err.stack;
    return msg = msg.replace(/^Error: /, '');
  }
};

log = function() {
  if (root.console == null) {
    return console.log.apply(console, arguments);
  }
};

fn = function(method) {
  var prefix;
  prefix = colors[method](method + ' ');
  return log[method] = function(msg, extra) {
    var err;
    err = null;
    switch (typeof msg) {
      case 'string':
        msg = msg;
        break;
      case 'object':
        if (msg instanceof Error) {
          msg = prettyError(msg);
        } else {
          msg = '\n' + prettyJSON(msg);
        }
    }
    if (extra instanceof Error) {
      extra = prettyError(extra);
    } else {
      extra = prettyJSON(extra);
    }
    if (extra != null) {
      msg = msg + '\n' + extra;
    }
    msg = prefix + msg;
    if (err != null) {
      return console.error(msg);
    } else {
      return console.log(msg);
    }
  };
};
for (method in theme) {
  _ = theme[method];
  fn(method);
}

var log$1 = log;

// src/middleware/fake-express.coffee
var fakeExpress = function(req, res, next) {
  var url$$1;
  res.redirect = function(loc) {
    res.writeHead(302, {
      Location: loc
    });
    return res.end();
  };
  res.set = function(headers) {
    var k, results, v;
    results = [];
    for (k in headers) {
      v = headers[k];
      results.push(res.setHeader(k, v));
    }
    return results;
  };
  res.send = function(body) {
    return res.end(body);
  };
  url$$1 = url.parse(req.url);
  req.path = url$$1.pathname;
  req.search = url$$1.search;
  return next();
};

// src/middleware/live-reload.coffee
var LiveReload;
var livereload;
var serveStatic$1;

serveStatic$1 = function(req, res, next) {
  var contentType, file;
  switch (path.extname(req.url)) {
    case '.js':
      contentType = 'application/javascript';
      break;
    case '.coffee':
      contentType = 'application/coffeescript';
      break;
    case '.map':
      contentType = 'application/json';
      break;
    default:
      next();
  }
  if (/^\/src\/node_modules/.test(req.url)) {
    req.url = req.url.substring(4);
  }
  file = path.join(__dirname, '/..', req.url);
  res.writeHead(200, {
    'Content-Type': contentType
  });
  return fs.createReadStream(file).pipe(res);
};

LiveReload = (function() {
  function LiveReload(opts) {
    if (opts == null) {
      opts = {};
    }
    this.js = "<script src=\"/bebop.min.js\"></script>\n<script>\n  var bebop = new Bebop(" + (JSON.stringify(opts)) + ");\n  bebop.debug = true;\n  bebop.connect();\n</script>";
  }

  LiveReload.prototype.injectJs = function(res) {
    var appendScript, end, setHeader;
    appendScript = false;
    end = res.end;
    setHeader = res.setHeader;
    res.setHeader = (function(_this) {
      return function(name, value) {
        if (/text\/html/i.test(value)) {
          appendScript = true;
        } else if (name === 'Content-Length' && appendScript) {
          value = parseInt(value, 10) + _this.js.length;
        }
        return setHeader.call(res, name, value);
      };
    })(this);
    return res.end = (function(_this) {
      return function(chunk, encoding) {
        if (appendScript) {
          res.write(_this.js, encoding);
        }
        return end.call(res, chunk, encoding);
      };
    })(this);
  };

  LiveReload.prototype.middleware = function(req, res, next) {
    if (/^\/bebop|src\/client\/bebop/.test(req.url)) {
      return this.serveStatic(req, res, next);
    }
    this.injectJs(res);
    return next();
  };

  return LiveReload;

})();

var liveReload = livereload = function(opts) {
  var r;
  if (opts == null) {
    opts = {};
  }
  r = new LiveReload(opts);
  return function liveReload(req, res, next) { return r.middleware(req, res, next); };
};

// src/middleware/node-modules-redirect.coffee
var nodeModulesRedirect;

var nodeModulesRedirect$1 = nodeModulesRedirect = function(req, res, next) {
  var nm;
  nm = req.path.indexOf('node_modules');
  if (~nm) {
    res.writeHead(301, {
      Location: "/" + (req.path.substr(nm))
    });
    return res.end();
  } else {
    return next();
  }
};

// src/middleware/strip-html.coffee
var stripHtml;
var trailingHtmlRe;

trailingHtmlRe = /\.html$/;

var stripHtml$1 = stripHtml = function(req, res, next) {
  var loc;
  if (!trailingHtmlRe.test(req.url)) {
    return next();
  }
  loc = req.url.replace(/index.html$/, '');
  loc = loc.replace(trailingHtmlRe, '');
  return res.redirect(loc);
};

// src/middleware/strip-slash.coffee
var stripSlash;
var trailingSlashRe;

trailingSlashRe = /\.html\/$/;

var stripSlash$1 = stripSlash = function(req, res, next) {
  var loc;
  if (!trailingSlashRe.test(req.url)) {
    return next();
  }
  loc = req.url.replace(trailingSlashRe, '.html');
  return res.redirect(loc);
};

// assets/github-markdown.css
var css = "";

// src/middleware/markdown.coffee
marked.setOptions({
  renderer: new marked.Renderer(),
  breaks: false,
  gfm: true,
  pedantic: false,
  sanitize: true,
  smartLists: true,
  smartypants: false,
  tables: true
});

var markdown = function(opts) {
  var maxAge;
  if (opts == null) {
    opts = {};
  }
  maxAge = opts.maxAge || 0;
  return function(req, res, next) {
    var path$$1, pathname;
    pathname = (url__default.parse(req.url, true, true)).pathname;
    if (!/\.md$/.test(pathname)) {
      return next();
    }
    path$$1 = pathname.replace(/^\//, '');
    return fs.exists(path$$1, function(exists) {
      var now;
      if (!exists) {
        return next();
      }
      now = new Date().toUTCString();
      res.setHeader('Content-Type', 'text/html; charset=UTF-8');
      if (!res.getHeader('Cache-Control')) {
        res.setHeader('Cache-Control', 'public, max-age=' + (maxAge / 1000));
      }
      if (!res.getHeader('Date')) {
        res.setHeader('Date', now);
      }
      if (!res.getHeader('Last-Modified')) {
        res.setHeader('Last-Modified', now);
      }
      if (req.method === 'HEAD') {
        res.writeHead(200);
        return res.end();
      }
      if (req.method !== 'GET') {
        return next();
      }
      return fs.readFile(path$$1, 'utf-8', function(err, data) {
        if (err != null) {
          throw err;
        }
        res.writeHead(200);
        return res.end("<html>\n  <head>\n    <title>" + path$$1 + "</title>\n    <style>\n    " + css + "\n    </style>\n  </head>\n  <body>\n  " + (marked(data)) + "\n  </body>\n</html>");
      });
    });
  };
};

// src/middleware/index.coffee

// src/utils.coffee
var defaultExclude = /bebop.coffee$|bebop.js$/;

var requireLocal = function(modulePath) {
  var err, localPath;
  localPath = path.join(process.cwd(), '/node_modules/', modulePath);
  try {
    return require(localPath);
  } catch (error) {
    err = error;
    try {
      return require(modulePath);
    } catch (error) {
      err = error;
      log$1.error(modulePath + ' not found, try npm install -g ' + modulePath);
      return process.exit(1);
    }
  }
};

var firstAddress = function() {
  var _, addr, i, iface, len, ref;
  ref = os.networkInterfaces();
  for (_ in ref) {
    iface = ref[_];
    for (i = 0, len = iface.length; i < len; i++) {
      addr = iface[i];
      if (addr.family !== 'IPv4') {
        continue;
      }
      if (addr.internal) {
        continue;
      }
      return addr.address;
    }
  }
};

// src/server.coffee
var Server;
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
var hasProp = {}.hasOwnProperty;

Server = (function(superClass) {
  extend(Server, superClass);

  function Server(opts) {
    var app, base, base1, base2, base3, base4, dir, i, len, ref, ref1, ref2, ref3, serverOpts;
    this.opts = opts != null ? opts : {};
    if (!(this instanceof Server)) {
      return new Server(this.opts);
    }
    if ((base = this.opts).host == null) {
      base.host = '0.0.0.0';
    }
    if ((base1 = this.opts).port == null) {
      base1.port = 1987;
    }
    if ((base2 = this.opts).buildDir == null) {
      base2.buildDir = process.cwd();
    }
    if ((base3 = this.opts).workDir == null) {
      base3.workDir = process.cwd();
    }
    if ((base4 = this.opts).hideIcon == null) {
      base4.hideIcon = false;
    }
    this.app = app = connect();
    app.use(fakeExpress);
    app.use(stripHtml$1);
    app.use(stripSlash$1);
    if (this.opts.hideIcon == null) {
      app.use(favicons(__dirname + '/../assets'));
    }
    app.use(logger('dev'));
    if (this.opts.user && this.opts.pass) {
      app.use(basicAuth(this.opts.user, this.opts.pass));
    }
    app.use(liveReload());
    app.use(markdown());
    serverOpts = {
      etag: false,
      fallthrough: true,
      dotfiles: (ref = this.opts.dotfiles) != null ? ref : 'deny',
      extensions: (ref1 = this.opts.extensions) != null ? ref1 : ['html', 'htm'],
      index: (ref2 = this.opts.index) != null ? ref2 : ['index.html', 'index.htm']
    };
    app.use(serveStatic(this.opts.buildDir, serverOpts));
    app.use(serveIndex(this.opts.buildDir, {
      hidden: true
    }));
    app.use('/node_modules', serveStatic(process.cwd() + '/node_modules', serverOpts));
    app.use(nodeModulesRedirect$1);
    ref3 = [this.opts.assetDir, this.opts.workDir];
    for (i = 0, len = ref3.length; i < len; i++) {
      dir = ref3[i];
      if ((dir != null) && dir !== '' && dir !== this.opts.buildDir) {
        app.use(serveStatic(dir, serverOpts));
      }
    }
    Server.__super__.constructor.call(this, app);
    this.setMaxListeners(100);
    this.once('listening', function() {
      var host;
      if (this.opts.host === '0.0.0.0') {
        host = firstAddress();
        log$1.bebop("serving " + (path.basename(this.opts.workDir)) + " at");
        console.log("    http://" + host + ":" + this.opts.port);
        return console.log("    http://localhost:" + this.opts.port);
      } else {
        return log$1.bebop("serving " + (path.basename(this.opts.workDir)) + " at http://" + this.opts.host + ":" + this.opts.port);
      }
    });
  }

  Server.prototype.run = function(cb) {
    if (cb == null) {
      cb = function() {};
    }
    process.once('uncaughtException', function(err) {
      if (err.code === 'EADDRINUSE') {
        log$1.error('address in use, retrying...');
        server.close();
        this.opts.port++;
        return setTimeout(server.run, 1000);
      } else {
        log$1.error(err);
        return process.exit(1);
      }
    });
    return this.listen(this.opts.port, this.opts.host, cb);
  };

  return Server;

})(http.Server);

var Server$1 = Server;

// src/websocket.coffee
var WebSocketServer;

WebSocketServer = (function() {
  function WebSocketServer(opts) {
    var id, server, wss;
    if (opts == null) {
      opts = {};
    }
    if (!(this instanceof WebSocketServer)) {
      return new WebSocketServer(opts);
    }
    if (typeof opts === 'function') {
      server = opts;
      opts = {
        server: server
      };
    }
    if (opts.server == null) {
      if (opts.port == null) {
        opts.port = 3456;
      }
    }
    if (opts.path == null) {
      opts.path = '/_bebop';
    }
    wss = new ws.Server(opts);
    this.clients = {};
    id = 0;
    wss.on('connection', function(ws$$1) {
      id += 1;
      ws$$1.id = id;
      this.clients[ws$$1.id] = ws$$1;
      return ws$$1.on('close', function() {
        return delete this.clients[ws$$1.id];
      });
    });
    this.wss = wss;
  }

  WebSocketServer.prototype.close = function() {
    var id;
    for (id in this.clients) {
      this.clients[id].close();
      delete this.clients[id];
    }
    return this.wss.close();
  };

  WebSocketServer.prototype.send = function(message) {
    var err, id, results;
    results = [];
    for (id in this.clients) {
      try {
        results.push(this.clients[id].send(JSON.stringify(message)));
      } catch (error) {
        err = error;
        results.push(console.error(err.stack));
      }
    }
    return results;
  };

  WebSocketServer.prototype.modified = function(filename) {
    return this.send({
      type: 'modified',
      filename: filename
    });
  };

  return WebSocketServer;

})();

var WebSocketServer$1 = WebSocketServer;

// node_modules/es-is/dist/index.mjs
// src/index.coffee
var isActualNaN;
var isArgs;
var isFn;
var objProto;
var owns;
var symbolValueOf;
var toStr;

objProto = Object.prototype;

owns = objProto.hasOwnProperty;

toStr = objProto.toString;

symbolValueOf = void 0;

if (typeof Symbol === 'function') {
  symbolValueOf = Symbol.prototype.valueOf;
}

isActualNaN = function(value) {
  return value !== value;
};

var isEqual = function(value, other) {
  var key, type;
  if (value === other) {
    return true;
  }
  type = toStr.call(value);
  if (type !== toStr.call(other)) {
    return false;
  }
  if (type === '[object Object]') {
    for (key in value) {
      if (!isEqual(value[key], other[key]) || !(key in other)) {
        return false;
      }
    }
    for (key in other) {
      if (!isEqual(value[key], other[key]) || !(key in value)) {
        return false;
      }
    }
    return true;
  }
  if (type === '[object Array]') {
    key = value.length;
    if (key !== other.length) {
      return false;
    }
    while (key--) {
      if (!isEqual(value[key], other[key])) {
        return false;
      }
    }
    return true;
  }
  if (type === '[object Function]') {
    return value.prototype === other.prototype;
  }
  if (type === '[object Date]') {
    return value.getTime() === other.getTime();
  }
  return false;
};

var isArrayLike = function(value) {
  return !!value && !isBool(value) && owns.call(value, 'length') && isFinite(value.length) && isNumber(value.length) && value.length >= 0;
};

var isArguments = isArgs = function(value) {
  var isOldArguments, isStandardArguments;
  isStandardArguments = toStr.call(value) === '[object Arguments]';
  isOldArguments = !isArray(value) && isArrayLike(value) && isObject(value) && isFn(value.callee);
  return isStandardArguments || isOldArguments;
};

var isArray = Array.isArray || function(value) {
  return toStr.call(value) === '[object Array]';
};

var isBool = function(value) {
  return toStr.call(value) === '[object Boolean]';
};

var isFunction = isFn = function(value) {
  var isAlert, str;
  isAlert = typeof window !== 'undefined' && value === window.alert;
  if (isAlert) {
    return true;
  }
  str = toStr.call(value);
  return str === '[object Function]' || str === '[object GeneratorFunction]' || str === '[object AsyncFunction]';
};

var isNumber = function(value) {
  return toStr.call(value) === '[object Number]';
};

var isObject = function(value) {
  return toStr.call(value) === '[object Object]';
};

var isPromise = function(value) {
  return !!value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function';
};

var isString = function(value) {
  return toStr.call(value) === '[object String]';
};

// src/compilers/sass.coffee
var findNpm;
var resolveNpm;

findNpm = function(url$$1) {
  var err;
  try {
    return path.relative(process.cwd(), require.resolve(url$$1));
  } catch (error) {
    err = error;
    return path.relative(process.cwd(), require.resolve(url$$1));
  }
};

resolveNpm = (function() {
  var cache;
  cache = {};
  return function(url$$1, file, cb) {
    var e, newPath;
    if (cache[url$$1] != null) {
      return cb({
        file: cache[url$$1]
      });
    }
    try {
      newPath = findNpm(url$$1);
      cache[url$$1] = newPath;
      return cb({
        file: newPath
      });
    } catch (error) {
      e = error;
      cache[url$$1] = url$$1;
      return cb({
        file: url$$1
      });
    }
  };
})();

var sass = function(src, dst, cb) {
  var sass;
  sass = requireLocal('node-sass');
  return sass.render({
    file: src,
    includePaths: [path.join(process.cwd(), 'node_modules')],
    outputStyle: 'nested'
  }, function(err, res) {
    if (err != null) {
      throw err;
    }
    return fs.writeFile(dst, res.css, function(err) {
      if (err != null) {
        throw err;
      }
      return cb(null, true);
    });
  });
};

// src/compilers/pug.coffee
var pug = function(src, dst, cb) {
  var html, pug;
  if (cb == null) {
    cb = function() {};
  }
  pug = requireLocal('pug');
  html = pug.renderFile(src, {
    pretty: true
  });
  return fs.writeFile(dst, html, function(err) {
    if (err != null) {
      throw err;
    }
    return cb(null, true);
  });
};

// src/compilers/index.coffee
var compilers;

var compilers$1 = compilers = {
  mappings: {
    coffee: 'js',
    hbs: 'html',
    jade: 'html',
    pug: 'html',
    sass: 'css',
    scss: 'css',
    styl: 'css'
  },
  compile: function(filename, opts, cb) {
    var c, cmd, cmds, compiler, dst, ext, ref, src;
    if (opts == null) {
      opts = {};
    }
    if (cb == null) {
      cb = function() {};
    }
    if (typeof opts === 'function') {
      ref = [{}, opts], opts = ref[0], cb = ref[1];
    }
    ext = (path.extname(filename)).substr(1);
    if ((compiler = this[ext]) == null) {
      return cb(null, false);
    }
    src = filename;
    dst = filename.replace(new RegExp(ext + '$'), this.mappings[ext]);
    if (opts.buildDir != null) {
      dst = dst.replace(opts.assetDir, opts.buildDir);
    }
    if (compiler.length === 3) {
      return compiler(src, dst, cb);
    }
    cmd = compiler(src, dst);
    if (isFunction(cmd)) {
      return cmd(cb);
    }
    if (isPromise(cmd)) {
      return cmd;
    }
    if (!isString(cmd)) {
      return cb(null, cmd != null ? cmd : false);
    }
    cmds = (function() {
      var i, len, ref1, results;
      ref1 = cmd.split(';');
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        c = ref1[i];
        if ((c != null) && c.trim() !== '') {
          results.push(c.trim());
        }
      }
      return results;
    })();
    return exec.quiet(cmds, function(err, stdout, stderr) {
      if (err != null) {
        return cb(err);
      }
      if ((stderr != null) && stderr.trim() !== '') {
        return cb(new Error(stderr));
      }
      return cb(null, true);
    });
  },
  coffee: function(src, dst) {
    dst = path.dirname(dst);
    return "coffee -bmc -o " + dst + " " + src;
  },
  hbs: function(src, dst) {
    var handlebars, template;
    handlebars = requireLocal('handlebars');
    template = handlebars.compile(fs.readFileSync(src, 'utf8'));
    return fs.writeFileSync(dst, template({}), 'utf8');
  },
  jade: function(src, dst) {
    dst = path.dirname(dst);
    return "jade --pretty " + src + " --out " + dst;
  },
  pug: pug,
  styl: function(src, dst) {
    dst = path.dirname(dst);
    return "stylus " + src + " -o " + dst;
  },
  sass: sass,
  scss: sass
};

// package.json


var version = "1.11.6";

// src/cli.coffee
var args;
var bits;
var compile;
var compiler;
var conf;
var confs;
var credentials;
var cwd;
var err;
var error$1;
var ext;
var i;
var j;
var len;
var len1;
var mod;
var opt;
var opts;
var p;
var ref;
var ref1;
var ref2;
var ref3;
var relativeName;
var requireConfig;
var server$1;
var usage;
var version_;
var vigilOpts;
var websocket;

error$1 = function(message) {
  log$1.error(message);
  return process.exit(1);
};

version_ = function() {
  console.log(version);
  return process.exit(0);
};

usage = function() {
  console.log("bebop <command> [options] [file]\n\nCommands:\n  compile|c  Compile files and exit\n  help       Display this message\n  version    Display version\n\nOptions:\n  --auto                      Automatically compile even without a local config file\n  --compilers <ext:compiler>  Specify compiler to use for a given extension\n  --config <file>             Specify bebop.coffee to use\n  --exclude, -x <file>        Exclude files from watching, compiling\n  --force-reload              Force reload when file is compiled\n  --host, -h <hostname>       Hostname to bind to\n  --include, -i <file>        Include files for watching, compiling\n  --no-server                 Do not run static file server\n  --no-watch                  Do not watch files for changes\n  --open, -o                  Open browser automatically\n  --port, -p <port>           Port to listen on\n  --secure, -s <user:pass>    Require authentication\n  --asset-dir <path>          Directory used as root for compiling, watching\n  --build-dir <path>          Directory used as root for static file server\n  --work-dir  <path>          Directory used as root for process\n  --index <file>              Index file to attempt to serve when directory requested\n  --hide-icon                 Hide Bebop's favicon");
  return process.exit(0);
};

try {
  require('coffee-script/register');
} catch (error1) {
  err = error1;
}

cwd = process.cwd();

confs = [process.env.HOME + '/.bebop', cwd + '/.bebop', cwd + '/bebop'];

opts = {
  compile: false,
  compileOnly: false,
  compilers: {},
  defaultExclude: true,
  exclude: [],
  fallback: null,
  forceReload: false,
  host: '0.0.0.0',
  include: [],
  index: ['index.html', 'index.htm'],
  initialPath: '',
  port: null,
  runServer: true,
  watch: true,
  assetDir: cwd,
  buildDir: cwd,
  workDir: cwd,
  hideIcon: false
};

requireConfig = function(path$$1) {
  var conf, k, ref, v;
  try {
    conf = require.resolve(path$$1);
  } catch (error1) {
    err = error1;
    return;
  }
  if (fs.existsSync(conf)) {
    ref = require(conf);
    for (k in ref) {
      v = ref[k];
      opts[k] = v;
    }
    return opts.compile = true;
  }
};

for (i = 0, len = confs.length; i < len; i++) {
  conf = confs[i];
  requireConfig(conf);
}

args = process.argv.slice(2);

while (opt = args.shift()) {
  switch (opt) {
    case 'compile':
    case 'c':
    case '--compile':
    case '-c':
      opts.compileOnly = true;
      break;
    case 'help':
    case '--help':
      usage();
      break;
    case 'version':
    case '--version':
    case '-v':
      version_();
      break;
    case '--config':
      requireConfig(args.shift());
      break;
    case '--open':
    case '-o':
      opts.open = true;
      break;
    case '--no-server':
      opts.runServer = false;
      break;
    case '--no-watch':
      opts.watch = false;
      break;
    case '--auto':
      opts.compile = true;
      break;
    case '--include':
    case '-i':
      opts.include.push(args.shift());
      break;
    case '--exclude':
    case '-x':
      opts.exclude.push(args.shift());
      break;
    case '--no-default-exclude':
      opts.defaultExclude = false;
      break;
    case '--force-reload':
      opts.forceReload = true;
      break;
    case '--fallback':
      opts.fallback = args.shift();
      break;
    case '--host':
    case '-h':
      opts.host = args.shift();
      break;
    case '--port':
    case '-p':
      p = args.shift();
      if (!p) {
        error$1('missing port');
      }
      opts.port = parseInt(p, 10);
      break;
    case '--secure':
    case '-s':
      credentials = args.shift();
      if (credentials) {
        ref = credentials.split(':'), opts.user = ref[0], opts.pass = ref[1];
      } else {
        opts.user = 'bebop';
        opts.pass = 'beepboop';
      }
      break;
    case '--asset-dir':
      opts.assetDir = args.shift();
      break;
    case '--build-dir':
      opts.buildDir = args.shift();
      break;
    case '--work-dir':
      opts.workDir = args.shift();
      break;
    case '--compilers':
    case '-c':
      ref1 = args.shift().split(',');
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        compiler = ref1[j];
        ref2 = compiler.split(':'), ext = ref2[0], mod = ref2[1];
        opts.compilers[ext] = mod;
      }
      break;
    case '--hide-icon':
      opts.hideIcon = true;
      break;
    default:
      if (opt.charAt(0) === '-') {
        error$1("Unrecognized option: '" + opt + "'");
      } else {
        opts.initialPath = opt;
      }
  }
}

if (opts.defaultExclude) {
  opts.exclude = [vigil.utils.excludeRe, defaultExclude].concat(opts.exclude);
}

vigilOpts = {
  exclude: opts.exclude,
  include: opts.include,
  patch: false
};

ref3 = opts.compilers;
for (ext in ref3) {
  compiler = ref3[ext];
  if (typeof compiler === 'string') {
    try {
      bits = compiler.split('.');
      compiler = require(bits.shift());
      while (bits.length) {
        compiler = compiler[bits.shift()];
      }
      compilers$1[ext] = compiler;
    } catch (error1) {
      err = error1;
      console.log(err);
    }
  } else {
    compilers$1[ext] = compiler;
  }
}

relativeName = function(filename) {
  return filename.replace(opts.workDir + '/', '');
};

compile = function(filename, cb) {
  if (cb == null) {
    cb = function() {};
  }
  return compilers$1.compile(filename, opts, function(err, compiled) {
    filename = relativeName(filename);
    if (err != null) {
      log$1.error("failed to compile " + filename, err);
      return;
    }
    if (compiled) {
      log$1.compiled(filename);
    }
    return cb(null, compiled);
  });
};

if (opts.compile) {
  vigil.walk(opts.workDir, vigilOpts, function(filename) {
    if (opts.compile) {
      return compile(filename);
    }
  });
}

if (opts.compileOnly) {
  process.exit(0);
}

if (opts.runServer) {
  server$1 = new Server$1(opts);
  websocket = new WebSocketServer$1(server$1);
} else {
  server$1 = {
    run: function() {}
  };
  websocket = {
    modified: function() {}
  };
}

if (opts.watch) {
  vigil.watch(opts.assetDir, vigilOpts, function(filename) {
    if (!opts.compile) {
      log$1.modified(filename);
      return websocket.modified(filename);
    }
    return compile(filename, function(err, compiled) {
      if (!compiled) {
        log$1.modified(filename);
        return websocket.modified(filename);
      } else {
        if (opts.forceReload) {
          return websocket.modified(filename);
        }
      }
    });
  });
  if (opts.buildDir !== opts.assetDir) {
    vigil.watch(opts.buildDir, vigilOpts, function(filename) {
      log$1.modified(filename);
      return websocket.modified(filename);
    });
  }
}

server$1.run(function() {
  if (opts.open || opts.initialPath !== '') {
    switch (os.platform()) {
      case 'darwin':
        return exec("open http://" + opts.host + ":" + opts.port + "/" + opts.initialPath);
      case 'linux':
        return exec("xdg-open http://" + opts.host + ":" + opts.port + "/" + opts.initialPath);
    }
  }
});
//# sourceMappingURL=bebop.map
